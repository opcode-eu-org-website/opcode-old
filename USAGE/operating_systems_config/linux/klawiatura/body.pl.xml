<article>
<title>Klawiatura</title>

<p>Uwagi ogólne dotyczących konfigurowania klawiatury tak pod konsolą jak i pod X'ami:</p>
<ul>
	<li>mapę klawiszy pod konsolą ustawiamy poleceniem <code>loadkeys /usr/share/keymaps/i386/qwerty/pl.kmap.gz</code>, za domyślną mapę klawiatury odpowiada <kbd class="path">/etc/console/boottime.kmap.gz</kbd> jest ona wczytywana przez skrypt startowy <kbd class="path">/etc/init.d/keymap.sh</kbd></li>
	<li>mapę klawiszy w X'ach ustawiamy poleceniem <code>setxkbmap -model pc104 -layout pl -variant basic</code>, za ustawienia domyslne odpowiadają wpisy w <kbd class="path">/etc/X11/xorg.conf</kbd>, istotne są także ustawienia używanego środowiska takiego jak KDE czy gnome</li>
	<li>za wybór układu fizycznej klawiatury pod konsolą odpowiadają ustawienia w <kbd class="path">/proc</kbd> (dokonywane przez <kbd class="path">/etc/init.d/keymap.sh</kbd>), pod X'ami są to wpisy w pliku konfiguracyjnym i opcje <code>setxkbmap</code></li>
</ul>

<p>Należy także rozróżniać ustawienia klawiatury, od ustawienia czcionek, od ustawienia locali. Ustawienia klawiatury (opisane powyżej odpowiadają za to jakie znaki jesteśmy wstanie wprowadzić), ustawienia czionek (pod konsolą wpis <code>SCREEN_FONT=<var>iso02.f16</var></code> w <kbd class="path">/etc/console-tools/config</kbd>) odpowiadają za to jakie znaki system jest w stanie wyświetlić. Natomiast ustawienia locale (zmienne <code>LANG</code> i <code>LC_*</code>, ustawienie ogólnosystemowe w <kbd class="path">/etc/environment</kbd>) odpowiadają za to w jakim języku "rozwmawia" z nami większość programów, w jaki sposób zakodowane są znaki non-asci w tych rozmowach, oraz za domyślne kodowanie w wielu edytorach tekstowych.</p>

<p>Oprócz typowego wprowadzania znaków niedostępnych bezpośrednio (metoda ta nie ogranicza się tylko do polskich ogonków) z użyciem modyfikatora Alt-Gr (prawy Alt) możliwe jest także wprowadzania niedostępnych znaków przy pomocy uzyskiwanego przez niektóre z kombinacji Alt-Gr <wiki pl="Martwy klawisz">martwego klawisza</wiki> oraz <wiki pl="Klawisz komponujący">klawisza komponującego</wiki>. Aby skorzystać z klawisza komponującego konieczne jest przypisanie go do ktyóregoś z modyfikatorów na klawiaturze np. do prawego WinKey - można to zrobić poprzez <code>setxkbmap -option compose:rwin</code> lub rekonfigurację pakietu "keyboard-configuration". Klawisz komponujący potwrafi używać indywidualnej mapy dla użytkownika umieszczonej w pliku <kbd class="path">~/.XCompose</kbd> (za wzorzec mogą posłuyzyć mapy systemowe z <kbd class="path">/usr/share/X11/locale/*/Compose</kbd>). W ostateczności można także znak przekopiować z jakiejś tablicy znaków Unicode. Zobacz także: <wiki pl="Alt-kody">Alt-kody</wiki>, <doc url="http://dug.net.pl/tekst/151/">Wprowadzanie znaków niedostępnych na klawiaturze</doc></p>


<subtitle>Klawiatura numeryczna i kropka</subtitle>
<p>Aby uzyskamy kropkę zamiast przecinka na klawiaturze numerycznej należy wykomentować w pliku <kbd class="path">/usr/share/X11/xkb/symbols/pl</kbd> linijkę <code>include "kpdl(comma)"</code> (dawniej <code>include "keypad(comma)"</code>) w sekcji odpowiadającej naszej klawiaturze (dla "polski programisty" sekcja "basic").</p> 

<p>W środowisku graficznym taki efekt możemy także uzuskać komendą: <code>setxkbmap pl; xmodmap -e "keycode 91 = KP_Delete period KP_Delete period"</code>. Program ten może także posłużyć do innych modyfikacji klawiatury np. <code>xmodmap -e "clear mod1" -e "clear mod3"  -e "clear mod4"; xmodmap -e "add mod1 = Alt_L" -e "add mod3 = Super_R"  -e "add mod4 = Super_L"</code>.</p>


<subtitle>Klawiatura multimedialna i nie tylko</subtitle>
<p>W przypadku konsoli po wciśnięciu jakiegoś z dodatkowych przycisków zobaczymy komunikat o nieznanym numerze klawisza możemy wtedy przy pomocy programu <code>setkeycodes</code> przypisać mu konwencjonalny numer i następnie wykorzystać go w mapie klawiatury. W przypadku klawiszy mających już przypisany konwencjonalny numer możemy go poznać za pomocą komendy <code>showkey</code>.</p>

<p>W przypadku X'ów możemy skorzystać z programów pozwalających na przypisanie tym klawiszom komendy (takich jak "hotkeys" czy "xbindkeys"). Możemy jednak przypisać im normalne oznaczenia funkcyjne poprzez xmodmap i keycode (przykładowy plik konfiguracyjny <a class="int" href="./xmodmaprc">.xmodmaprc</a>). Kody klawiszy zczytać możemy przy wykorzystaniu programu <code>xev</code>, natomiast listę nazw do których mogą być przypisane można znaleźć w pliku <kbd class="path">/usr/lib/X11/XKeysymDB</kbd>. Następnie po wykonaniu <code>xmodmap ~/.xmodmaprc</code> (warto wpisać jako w autostarcie) możemy tych klawiszy używać jak każdych innych - w ustawieniach skrótów klawiaturowych w aplikacjach, w konfiguracji menu KDE.</p>

<p>Klawisze te możemy w szczególności wykorzystać w dość rozbudowanym systemie akcji klawiaturowych oferowanym przez KDE. Znajdziemy go w "regionalne i dostępność" -> "Input Action" (jeden z znajdujących się tam przykładów pokazuje jak zrobić aby skrót klawiaturowy wpisywał podany tekst, oprócz tego możemy definiować skróty wieloklawiszowe (specjalny + coś i kolejne stanowiące napis ...).</p>


<subtitle>Odbiornik IR i sterowanie pilotem</subtitle>
<p>Możliwe jest także korzystanie z pilotów podczerweni do sterowania komputerem z linuxem. Wiele z tunerów telewizyjnych DVB posiada wbudowany odbiornik podczerwieni, jeżeli jest on obsługiwany przez nasze jądo mapowania jego przycisków na sygnały klawiatury możemy dokonać z wykorzystaniem <code>ir-keytable</code>. W przypadku popularnego układu RTL2832U opis konfiguracji możemy znaleźć w <doc url="http://www.linuxtv.org/wiki/index.php/RealTek_RTL2832U#Remote_Control">stosownym artykule na linuxtv.org</doc>.
	Plik z tablicą mapowań zapisujemy w <kbd class="path">/etc/rc_keymaps/</kbd>, testowanie (uzyskiwanie iformacji o identyfikatorze wciśniętego przycisku) przeprowadzamy przy pomocy komendy: <code>ir-keytable -s rc0 -t -v</code>, przeładowanie używanej tablicy przy pomocy <code>ir-keytable -s rc0 -w <var>/etc/rc_keymaps/rtl_simple</var></code> (uwaga: po dodaniu nowych <code>KEY_<var>XXXX</var></code> do tablicy aby były zauważone w xev należy zrestatować xserver; wynika to z tego ze xserwer ogranicza sie do obslugi eventow odczytanych na starcie z /dev/input/event* jako obsługiwane przez dane urzadzenie, możemy je odczytać manualnie z yzyciem polecenia <code>evtest <var>/dev/input/event12</var></code>).
	Informację na temat mapowania symboli <code>KEY_<var>XXXX</var></code> na symbole uzywane w Xach mozna podejrzec np. w: <doc url="http://ftp.suse.com/pub/people/sbrabec/keyboards/input_linux_map_fixed_old.txt">input_linux_map_fixed_old.txt</doc>
</p>

<p>aby ustawienia były wczytywane automatycznie po starcie systemu / podłączeniu urządzenia należy w pliku <kbd class="path">/etc/rc_maps.cfg</kbd> dodać wpis wiąrzący moduł obsługujący odbiornik IR z mapą klawiszy - np: <code>dvb_usb_rtl28xxu  *   rtl_simple</code>, gdzie mapa zapisana w pliku <kbd class="path">/etc/rc_keymaps/rtl_simple</kbd> ma postać:</p>
<pre>
# table rtl_simple, type: NEC

# duzy pilot - srodkowe "kolko" (L, R, ENTER, UP, DOWN)
0xe5004c KEY_PREVIOUSSONG
0xe50040 KEY_NEXTSONG
0xe50006 KEY_PLAYPAUSE
0xe50044 KEY_VOLUMEUP
0xe50048 KEY_VOLUMEDOWN

# duzy pilot - numeryczne (1, 3, 4, 6, 7, 9) jako jump
0xe50009 KEY_BACK
0xe50001 KEY_FORWARD
0xe5004b KEY_PAGEUP
0xe50043 KEY_PAGEDOWN
0xe5004a KEY_HOME
0xe50042 KEY_END

# inne
0xe50057 KEY_PLAYPAUSE
0xe5005e KEY_PLAYPAUSE
0xe5005a KEY_STOPCD
</pre>
</article>
