<article>
<title>Wirtualizacja - XEN</title>

<p><wiki pl="Xen">Xen</wiki> jest monitorem maszyn wirtualnych. Na komputerze na którym funkcjonuje uruchamiany jest najpierw sam Xen, a dopiero potem on uruchamia wskazane jądro systemu operacyjnego (odbywa się to poprzez odpowiedni wpis w bootloaderze, w którym ścieżka obrazu jądra i jego ram dysku są przekazywane jako parametry do ładowanego jądra xen'a). Poniżej zamieszam przykład takiego wpisu wraz z opcjami wystawiającymi konsolę XEN i dom0 na port szeregowy (ttyS1):</p>
<pre>title           Xen 3.2-1-amd64 / Debian GNU/Linux, kernel 2.6.26-2-xen-amd64
root            (hd0,0)
kernel          /boot/xen-3.2-1-amd64.gz com1=9600,8n1 console=com1,vga dom0_mem=256M
module          /boot/vmlinuz-2.6.26-2-xen-amd64 root=/dev/sdb1 ro console=tty0 console=hvc0
module          /boot/initrd.img-2.6.26-2-xen-amd64
</pre>

<p>Podstawowy system operacyjny uruchamiany przez Xen określany jest jako dom0, inne jako domU. Wspomniany dom0 charakteryzuje się posiadaniem dostępu do całego sprzętu, który nie został jawnie przekazany któremuś z domU (tak samo z pamięcią i czasem procesora). Poszczególne domU uruchamiane (i kontrolowane/zarządzane) są z dom0 przy pomocy komendy <code>xm</code>, do startu mogą wykorzystywać nawet ten sam obraz jądra, initrd i (ew.) dysku co dom0 (w tym wypadku w trybie ro lub po prostu kopię). Zobacz <man>xm</man> i <man>xmdomain.cfg</man>.</p>

<p>Xen zapewnia komunikację sieciową z systemami wirtualnymi. Realizowane jest to poprzez tworzenie w dom0 wirtualnych interfejsów związanych z interfejsami w domU, interfejsy te noszą oznaczenia <code>vif<var>X</var>.<var>Y</var></code>, gdzie <var>X</var> identyfikuje domU do którego prowadzi dany interfejs, a <var>Y</var> jest kolejnym numerem takiego interfejsu (domyślnie ich liczba dla każdego domU odpowiada liczbie fizycznych interfejsów w dom0). Ich wykorzystanie zależy od wartości <code>network-script</code> oraz <code>vif-script</code> w <kbd class="path">/etc/xen/xend-config.sxp</kbd> (pierwsza wskazuje nazwę skryptu odpalanego przy starcie dom0 celem przygotowania go do dostarczania sieci domU, druga wskazuje nazwę skryptu odpalanego przy uruchamianiu domU celem udostępnienia mu sieci, skrypty te znajdują się w <kbd class="path">/etc/xen/scripts</kbd>). W dalszej części będę zakładał że sieć udostępniana jest poprzez <id_link id="ABC_OF_COMPUTING:networks:ethernet:software_switching">bridge</id_link> przy ustawieniach: <code>(vif-script vif-bridge)</code> i <code>(network-script network-dummy)</code> oraz następującej zawartości <kbd class="path">/etc/xen/scripts/network-dummy</kbd>:</p>
<pre>/etc/xen/scripts/network-bridge $1 vifnum=0 netdev=eth0
/etc/xen/scripts/network-bridge $1 vifnum=1 netdev=eth1
</pre>

<p>O ilości interfejsów w poszczególnych domU decyduje wpis postaci <code>vif  = [ 'bridge=eth0,mac=00:16:3E:00:00:00', 'bridge=eth1,mac=00:16:3E:00:00:01' ]</code> w konfiguracji danego domU. W tym przypadku utworzone będą dwa interfejsy o podanych adresach MAC, a odpowiadające im interfejsy <code>vif<var>X</var>.<var>Y</var></code> w dom0 zostaną włączone do wskazanych bridge'ów. Bridge te (eth0 i eth1) zostaną utworzone przez podany powyżej skrypt <kbd class="path">network-dummy</kbd> i zostaną włączone do nich odpowiednie interfejsy <code>peth</code>. Jednak aby <kbd class="path">network-bridge</kbd> zadziałał poprawnie muszą być przed jego wywołaniem przez xend skonfigurowane poprzez ifup (<kbd class="path">/etc/network/interfaces</kbd>) odpowiednie interfejsy eth (zamiany nazwy z eth na peth dokonuje wspomniany skrypt przed utworzeniem odpowiedniego bridge'a i przenosi konfigurację z fizycznej karty na bridge'a, a fizyczna karta staje się portem bridge'a).</p>

<p>W wpisach <code>vif = ...</code> nie ma formalnego wymogu podawania MAC adresów tworzonych w domU interfejsów, jednak warto to robić aby wiedzieć co jest co oraz aby udev w domU nie przenumerowywał kart (gdyż jeżeli go nie podamy za każdym startem domU będzie generowany losowy z prefiksem 00:16:3E). Warto także zadbać aby udev przypisywał do tych MAC'ow odpowiednie numery interfejsów - eth0 i eth1 (a nie jakieś z kosmosu). Alternatywnymi metodami do opisywanego tutaj bridge'owania jest realizacja zwykłego routingu lub routintgu z NAT pomiędzy siecią dochodzącą do dom0 a siecią domU.</p>

<p>W niektórych wersjach Xen'a występuje problem z wbudowaną synchronizacją zegarów domU z dom0. Jego rozwiązaniem jest rezygnacja z tego mechanizmu (bez niej nie da się ustawić zegara w domU) poprzez wpisanie 1 do <kbd class="path">/proc/sys/xen/independent_wallclock</kbd> oraz wykorzystanie np. ntpdate do synchronizacji czasu.</p>

<p>W przypadku Xen 3.2 gdy Xen odpalany jest z przekierowaniem swojej konsoli na ttyS* nie należy uruchamiać konsoli jądra ani getty dom0 na tym urządzeniu. W opcjach jądra dla dom0 (tak jak wyżej pokazano) podajemy <code>console=hvc0</code>, natomiast getty uruchamiamy na <kbd class="path">/dev/hvc0</kbd>, ewentualnie na <kbd class="path">/dev/console</kbd> (w obu wypadkach konfiguracja jak dla tty0 a nie ttyS0). Podobnie należy czynić z getty DomU aby mieć konsolę pod <code>xm console</code> (nie odpalamy na /dev/tty1 tylko na /dev/console).</p>

<p>Oprócz xen'a mamy także inne systemy wirtualizacji, takie jak (więcej na stronie z <a class="ext" href="http://virt.kernelnewbies.org/TechComparison">technicznym porównaniem systemów wirtualizacji</a> oraz w <a class="ext" href="http://wiki.debian.org/SystemVirtualization">Debian Wiki</a>):</p><ul>
	<li>(k)<wiki pl="QEMU">qemu</wiki> - w zasadzie to jest emulacja platformy x86</li>
	<li><wiki pl="Kernel-based Virtual Machine">Kernel-based Virtual Machine</wiki> (KVM) - najbardziej zbliżony do Xen'a z pośród opisywanych, główną różnicą jest to iż (jak sama nazwa wskazuje) oparty jest na jądrze linux'owym a nie niezależnym "hypervisor"</li>
	<li><wiki pl="VirtualBox">VirtualBox</wiki> - wirtualizacja na poziomie systemu</li>
	
	<li><wiki en="Linux-VServer">Linux-VServer</wiki>, <wiki en="OpenVZ">OpenVZ</wiki>, Linux Containers (LXC), User Mode Linux (UML), Schroot - wzbogacone systemy typu chroot/jail, to nie jest prawdziwa wirtualizacja (OpenVZ zawiera dodatkowo zwirtualizowany stos sieciowy), wydają się dobre jako zastosowania "serwer dla każdego użytkownika", zobacz w Sieci: <doc url="http://www.debian-administration.org/articles/566">schroot - chroot for any users</doc></li>
</ul>

<p>Zobacz w Sieci: <doc url="http://wiki.debian.org/Xen">Xen - Debian Wiki</doc>, <doc url="http://www.virtuatopia.com/index.php/Xen_Virtualization_Essentials">Xen Virtualization Essentials</doc>.</p>
</article>
