<article>
<title>Certyfikaty x509</title>
<p>Do szyfrowania i podpisywania możemy korzystać także z z certyfikatów takich jak wykorzystywane w połączeniach SSL. Istnieje kilka dróg generowania certyfikatów i kluczy tego typu. Możemy to zrobić np. w następujący sposób: <code>openssl req -new -x509 -days 4095 -newkey rsa:2048 -keyout ca_key.pem -out ca_cert.pem</code>, wygenerowany zostanie certyfikat podpisany przez samego siebie (opcja <code>-x509</code>), jeżeli dodana byłaby opcja <code>-nodes</code> klucz prywatny nie byłby zabezpieczony hasłem (jest to przydatne przy generowaniu certyfikatów dla serwerów - szyfrowanie www, poczty itp.).</p>

<p>Wygenerowany w sposób opisany powyżej zestaw certyfikatu i klucza możemy używać od razu do szyfrowania bądź do podpisywania próśb o certyfikat generowanych komendą: <code>openssl req -new -keyout server.key -out server.key</code> (UWAGA: w przypadku certyfikatów dla serwerów w "COMMON NAME" nazwa domeny dla której jest certyfikat, można użyć *.domena aby pasował do wszystkich hostów w domenie). Prośbę taką możemy przekazać do podpisu jakiemuś prawdziwemu CA lub podpisać sobie sami (wygenerowanym wcześniej kluczem): <code>openssl x509 -req -out server.crt -in server.key -CA ca_cert.pem -CAkey ca_key.pem -CAcreateserial -days 365</code>. Na koniec możemy usunąć hasło z klucza prywatnego (przydatne dla serwerów): <code>openssl rsa -in server.key -out server.key</code>.</p>

<p>Na potrzeby wielu programów konieczne będzie wyeksportowanie zestawu klucza i certyfikatu do formatu PKCS#12 - <code>openssl pkcs12 -export -in cert1_cert.pem -inkey cert1_key.pem -out cert1.p12</code>. Klucz taki możemy zaimportować np. do <strong>gpgsm</strong> - <code>gpgsm --import cert1.p12</code> (wcześniej odpalamy gpg-agent --daemon i eksportujemy tak jak sugeruje GPG_AGENT_INFO). Pozwoli to na włączenie funkcjonalności <wiki en="S/MIME">S/MIME</wiki> w <strong>kmail</strong>'u (wymagane pakiety gpgsm i kleopatra), w tym celu należy ponadto zaimportować certyfikaty CA - <code>gpgsm --import /etc/ssl/certs/ca-certificates.crt</code> i zakwalifikować wszystkie te (nasz i CA) certyfikaty jako zaufane - <code>gpgsm -k | grep fingerprint | while read tmp fpr; do echo "$fpr S relax"; done &gt; ~/.gnupg/trustlist.txt</code></p>

<!-- # eksport klucza publicznego z PKCS#12
openssl pkcs12 -in cert1.p12 -out cert1_pub.pem -nokeys -clcerts
openssl x509 -outform DER -out cert1_pub.cer -in cert1_pub.pem
openssl crl2pkcs7 -nocrl -outform DER -out cert1_pub.p7b  -certfile cert1_pub.pem

# eksport klucza publicznego z ASCCI CERT file
#openssl x509 -outform DER -out cert1_pub.cer -in cert1_cert.pem
#openssl crl2pkcs7 -nocrl -outform DER -out cert1_pub.p7b  -certfile cert1_cert.pem

# eksport certyfikatu CA
openssl x509 -in cert1_cert.pem -outform DER -out cert1_cert.der -->

<subtitle id="wieledomen">Problem wielu domen</subtitle>
<p>Znanym problemem związanym z certyfikatami SSL jest problem obsLugi wielu domen na jednym zestawie ip-port. Pierwotnie protokół przywiązał do takiego zestawy jeden cetryfikat co uniemożliwiaLo stawiania name based virtual host z ssl-em. Obecnie stosowane jest kilka rozwiązań tego problemu (jednak wszystkie miewają jakieś ograniczenia ze względu na kompatybilność z starszym oprogramowaniem):</p>
<ul>
	<li>wystawianie certyfikatów dla *.domena</li>
	<li>stosowanie kilku CN w jednym certyfikacie</li>
	<li>stosowanie dodatkowej informacji "DNS" w certyfikacie</li>
	<li>mechanizm <wiki en="Server Name Indication">Server Name Indication</wiki> pozwalający na podanie nazwy domenowej w trakcie negocjacji połączenia</li>
</ul>
<p>Przykładowa metoda generacji samopodpisanego certyfikatu mającego kilka CN i wpisów "DNS":</p>
<pre>
openssl genrsa -out server.key 1024
openssl req -new -config server.cfg -key server.key -out server.csr

# uzyskane żądanie certyfikatu możemy obejrzeć przy pomocy
# openssl req -in server.csr -text -noout

# samopodpisanie certyfikatu
openssl x509 -req -in server.csr -signkey server.key -extfile server.cfg -extensions v3_req -days 4095 -text -out server.crt
</pre>

<p>Wykorzystywany plik konfiguracyjny <kbd class="path">server.cfg</kbd> ma postać:</p>
<pre>
[ req ]
default_bits            = 1024
distinguished_name      = req_distinguished_name
req_extensions          = v3_req
prompt                  = no

[ v3_req ]
basicConstraints        = CA:FALSE
keyUsage                = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName          = @alt_names


[ req_distinguished_name ]
C=PL
L=miasto
O=organizacja
OU=jednostka
emailAddress=admin@example.org


[ alt_names ]
DNS.0 = sub.domena1.tld
DNS.1 = domena2.tld

[ req_distinguished_name ]
0.CN=sub.domena1.tld
1.CN=domena2.tld
</pre>

</article>
