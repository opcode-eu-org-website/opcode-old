// wymaga pakietu libi2c-dev

#include <linux/i2c-dev.h>
#include <errno.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/time.h>
#include <string.h>


#define I2C_DEVICE "/dev/i2c-1"
#define MULTIPLEXER_ADDR 0x74

/**
 * OBSŁUGA ZAPISU DO MODUŁÓW I2C Z OBSŁUGĄ MULTIPLEXERA
 */
int file = -1;
int current_i2c_sub_bus = 0;
int write_to_i2c(int i2c_sub_bus, int i2c_dev_addr, int i2c_reg_addr, int value) {
	int res;
	
	if (i2c_sub_bus != current_i2c_sub_bus) {
		/// switch multiplexer to i2c_sub_bus
		
		res = ioctl(file, I2C_SLAVE, MULTIPLEXER_ADDR);
		if (res < 0) {
			fprintf(stderr, "ERROR set device addres to multiplexer (0x%02x): %s\n", MULTIPLEXER_ADDR, strerror(errno));
			return -3;
		}
		
		res = i2c_smbus_write_byte(file, i2c_sub_bus);
		if (res < 0) {
			fprintf(stderr, "ERROR switch multiplexer (0x%02x) to line %d\n", MULTIPLEXER_ADDR, i2c_sub_bus);
			return -4;
		}
		
		current_i2c_sub_bus = i2c_sub_bus;
	}
	
	res = ioctl(file, I2C_SLAVE, i2c_dev_addr);
	if (res < 0) {
		fprintf(stderr, "ERROR set device addres to 0x%02x: %s\n", i2c_dev_addr, strerror(errno));
		return -1;
	}
	
	res = i2c_smbus_write_byte_data(file, i2c_reg_addr, value);
	if (res < 0) {
		fprintf(stderr, "ERROR write %d to reg 0x%02x on dev 0x%02x at %d I2C sub-bus\n", value, i2c_reg_addr, i2c_dev_addr, i2c_sub_bus);
		return -2;
	}
	
	return 0;
}

/**
 * OBSŁUGA ZESTAWU MODUŁÓW I2C - inicjalizacja, ustawianie wartości pojedynczego modułu
 */
int init() {
	int i, j, ret = 0;
	
	for (i=4; i<8; i++) {
		for (j=0x20; j<0x23; j++) {
			ret += write_to_i2c(i, j, 0x00, 0x00); // IODIR -> output
			ret += write_to_i2c(i, j, 0x09, 0x00); // GPIO -> disable LED
		}
			
		if (i != 4)  for (j=0x24; j<0x27; j++) {
			ret += write_to_i2c(i, j, 0x00, 0x00); // IODIR -> output
			ret += write_to_i2c(i, j, 0x09, 0x00); // GPIO -> disable LED
		}
	}
	
	return ret;
}

#define RED     0x20
#define GREEN   0x21
#define BLUE    0x22
#define OFFSET  0x04
static inline int set_leds(int i2c_sub_bus, int i2c_dev_addr, int value) {
	return write_to_i2c(i2c_sub_bus, i2c_dev_addr, 0x09, value);
}

/**
 * OBSŁUGA MATRYCY 5x11 PIKSELI RGB
 */

struct rgb {
	unsigned char r;
	unsigned char g;
	unsigned char b;
};

struct {
	unsigned char line;
	unsigned char offset;
	
	struct rgb    val;
	struct rgb    old;
} moduly[7] = {
	{7, 0, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}}, {7, OFFSET, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}}, 
	{6, 0, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}}, {6, OFFSET, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}}, 
	{5, 0, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}}, {5, OFFSET, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}}, 
	{4, 0, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}}
};

#define ROWS 11
#define COLS 5

struct {
	unsigned char modul;
	unsigned char bit;
} matryca[ROWS][COLS] = {
	/*  0 */  { {1, 0x04}, {2, 0x20}, {4, 0x01}, {5, 0x08}, {6, 0x40} },
	/*  1 */  { {1, 0x02}, {2, 0x10}, {3, 0x80}, {5, 0x04}, {6, 0x20} },
	/*  2 */  { {1, 0x01}, {2, 0x08}, {3, 0x40}, {5, 0x02}, {6, 0x10} },
	/*  3 */  { {0, 0x80}, {2, 0x04}, {3, 0x20}, {5, 0x01}, {6, 0x08} },
	/*  4 */  { {0, 0x40}, {2, 0x02}, {3, 0x10}, {4, 0x80}, {6, 0x04} },
	/*  5 */  { {0, 0x20}, {2, 0x01}, {3, 0x08}, {4, 0x40}, {6, 0x02} },
	/*  6 */  { {0, 0x10}, {1, 0x80}, {3, 0x04}, {4, 0x20}, {6, 0x01} },
	/*  7 */  { {0, 0x08}, {1, 0x40}, {3, 0x02}, {4, 0x10}, {5, 0x80} },
	/*  8 */  { {0, 0x04}, {1, 0x20}, {3, 0x01}, {4, 0x08}, {5, 0x40} },
	/*  9 */  { {0, 0x02}, {1, 0x10}, {2, 0x80}, {4, 0x04}, {5, 0x20} },
	/* 10 */  { {0, 0x01}, {1, 0x08}, {2, 0x40}, {4, 0x02}, {5, 0x10} }
};

void display_matryca() {
	int i, j;
	
	for (i=0; i<7; i++) {
		if (moduly[i].val.r != moduly[i].old.r) {
			if (set_leds(moduly[i].line, RED + moduly[i].offset, moduly[i].val.r) == 0 || set_leds(moduly[i].line, RED + moduly[i].offset, moduly[i].val.r) == 0)
				moduly[i].old.r = moduly[i].val.r;
		}
		if (moduly[i].val.g != moduly[i].old.g) {
			if (set_leds(moduly[i].line, GREEN + moduly[i].offset, moduly[i].val.g) == 0 || set_leds(moduly[i].line, GREEN + moduly[i].offset, moduly[i].val.g) == 0)
				moduly[i].old.g = moduly[i].val.g;
		}
		if (moduly[i].val.b != moduly[i].old.b) {
			if (set_leds(moduly[i].line, BLUE + moduly[i].offset, moduly[i].val.b) == 0 || set_leds(moduly[i].line, BLUE + moduly[i].offset, moduly[i].val.b) == 0)
				moduly[i].old.b = moduly[i].val.b;
		}
	}
}

void prepare_matryca(struct rgb image[ROWS][COLS], int iter) {
	int i, j, m, b;
	
	for (i=0; i<7; i++) {
		moduly[i].val.r = 0;
		moduly[i].val.g = 0;
		moduly[i].val.b = 0;
	}
	for (i=0; i<ROWS; i++) {
		for (j=0; j<COLS; j++) {
			m = matryca[i][j].modul;
			b = matryca[i][j].bit;
			
			if (image[i][j].r > iter)
				moduly[m].val.r   = moduly[m].val.r   | b;
			if (image[i][j].g > iter)
				moduly[m].val.g = moduly[m].val.g | b;
			if (image[i][j].b > iter)
				moduly[m].val.b  = moduly[m].val.b  | b;
		}
	}
}

/**
 * OBSŁUGA RENDERINGU RAMKI
 */
void render_frame(struct rgb image[ROWS][COLS]) {
	int i;
	int czas;
	struct timeval tv_1, tv_2;
	
	for(i=0; i<12; i++) {
		gettimeofday ( &tv_1, NULL );
		
		prepare_matryca(image, i);
		display_matryca();
		
		gettimeofday ( &tv_2, NULL );
			/// 64 ramki po 12 cykli modulacji koloru (PWM) na sekundę => 1000000 / (12*64) = 1300
			czas = 1300 - ((tv_2.tv_sec * 1000000 + tv_2.tv_usec) - (tv_1.tv_sec * 1000000 + tv_1.tv_usec));
			if (czas>0) usleep(czas);
	}
}



/**
 * OBSŁUGA RÓŻNYCH FUNKCJI RENDERINGU
 */
void stroboskop_white() {
	struct rgb image[ROWS][COLS] = {
		{ {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1} },
		{ {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1} },
		{ {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1} },
		{ {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1} },
		{ {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1}, {0x1, 0x1, 0x1} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }
	};
	unsigned char strob_cnt, strob_cnt2;
	char strob1, strob2;
	
	while(1) {
		if (strob_cnt%17 == 0) {
			strob2 = 1;
		} else if ((strob_cnt+strob_cnt2)%7 == 0) {
			strob2 = 0;
		}
		
		if (strob_cnt % 3) {
			strob1 = 1;
			strob_cnt2++;
		} else {
			strob1 = strob2;
		}
		
		strob_cnt++;
		
		prepare_matryca(image, strob1);
		display_matryca();
		
		usleep(70000);
	}
}

void stroboskop() {
	struct rgb image[ROWS][COLS] = {
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }
	};
	
	unsigned char strob_cnt, tmp;
	unsigned char strob1, strob2, strob3;
	unsigned char red, blue, yellow, white;
	
	while(1) {
		tmp = strob_cnt%16;
		if (tmp == 6) {
			blue = 0xff;
		} else if (tmp == 8) {
			red = 0x00;
		} else if (tmp == 14) {
			red = 0xff;
		} else if (tmp == 0) {
			blue = 0x00;
		}
		
		if (strob_cnt%18 == 0) {
			white  = 0x00;
			yellow = 0x00;
		} else if (strob_cnt%27 == 0) {
			white  = 0xff;
		} else if (strob_cnt%9 == 0) {
			yellow = 0xff;
		}
		
		tmp = strob_cnt%3;
		if (tmp == 1) {
			strob1 = 0xff;
		} else {
			strob1 = 0x00;
		}
		
		if (tmp == 2) {
			strob2 = 0xff;
		} else {
			strob2 = 0x00;
		}
		
		if (tmp == 0) {
			strob3 = 0xff;
		} else {
			strob3 = 0x00;
		}

		strob_cnt++;
		
		image[1][0].r = image[1][1].r = strob1 & red;
		image[1][3].b = image[1][4].b = strob2 & blue;
		image[1][2].r = image[1][2].g = strob3 & (yellow|white);
		image[1][2].b                       = strob3 & white;
		
		prepare_matryca(image, 0);
		display_matryca();
		
		usleep(70000);
	}
}

void colors() {
	struct rgb image[ROWS][COLS] = {
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }
	};
	
	int a, b, c, i;
	while(1)
		for (a=0; a<13; a++)
			for (b=0; b<13; b++)
				for (c=0; c<13; c++) {
					image[3][0].r = image[3][2].g = image[3][4].b = a;
					image[3][0].g = image[3][2].b = image[3][4].r = b;
					image[3][0].b = image[3][2].r = image[3][4].g = c;
					for (i=0; i<2; i++) render_frame(image);
				}
}

void choinka() {
	struct rgb image_A[ROWS][COLS] = {
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0xe, 0x0, 0xe}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xe, 0xe}, {0x0, 0x0, 0x0} },
		{ {0xe, 0xe, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0xe, 0x0, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0} },
		{ {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0x0, 0xe}, {0x0, 0xf, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }
	};

	struct rgb image_B[ROWS][COLS] = {
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0} },
		{ {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }
	};

	struct rgb image_C[ROWS][COLS] = {
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0xe, 0x6, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x6, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0x0, 0x0} },
		{ {0xe, 0xe, 0xe}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0} },
		{ {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0}, {0x0, 0xf, 0x0} },
		{ {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }
	};
	
	int i;
	
	while(1) {
		for (i=0; i<32; i++)
			render_frame(image_A);
		for (i=0; i<32; i++)
			render_frame(image_B);
		for (i=0; i<32; i++)
			render_frame(image_C);
	}
}

int main(int argc, char *argv[]) {
	int ret, i;
	
	file = open(I2C_DEVICE, O_RDWR);
	if (file < 0) {
		fprintf(stderr, "ERROR open I2C device file (%s): %s\n", I2C_DEVICE, strerror(errno));
		return -1;
	}
	
	if ( init() < 0 ) {
		fprintf(stderr, "ERROR init I2C devices\n");
		return -1;
	}
	
	if(argc == 2) {
		if (*(argv[1]) == '1') colors();
		if (*(argv[1]) == '2') stroboskop();
		if (*(argv[1]) == '3') stroboskop_white();
		if (*(argv[1]) == '9') choinka();
	}
}
