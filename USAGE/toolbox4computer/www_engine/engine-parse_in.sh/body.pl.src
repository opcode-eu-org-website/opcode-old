#########################################
#     FUNKCJE - PRZETWARZANIE PLIKÓW    #
#########################################

FUNCTIONS_HELP="$FUNCTIONS_HELP"

# funkcja zwraca ścieżkę do odpowiedniej wersji językowej lub wersji uniwersalnej
# $1 - katalog z plikiem do przetwarzania
# $2 - nazwa pliku to przetworzenia $3  - rozszerzenie pliku to przetworzenia
lang_file_name() {
	if [ -e "$1/$2.$WWW_LANG.$3" ]; then
		echo "$1/$2.$WWW_LANG.$3";
	elif [ -e "$1/$2.$3" ]; then
		echo "$1/$2.$3";
	else
		echo "/dev/null"
	fi
}

# $1 - katalog z plikem z którego zwrócić wartość pierwszego znacznika <title>
gettitle() {
	awk '
		BEGIN {
			RS="<title>"; FS="</title>"
		}
		NF>=2 {
			print $1
		}
	' "$(lang_file_name "$SRC_DIR/$1" body xml)" | tr '\n' ' '
}


#####################################
#     PRZETWARZANIE *.src DO XML    #
#####################################

# funkcja łączy body.src, intro.src oraz noty copyright
# $1 - katalog z plikami do przetwarzania
# $2 - typ
# $3 - czy wstawiać Copyright
# $4 - podaje informacje o dacie dla Copyright
# $5 - współautorzy
# $6 - dodatkowe informacje Copyright
#
# jeżeli $3 == no to $4 $5 $6 są ignorowane
#
# jeżeli $3 == yes to $4 jest obowiązkowy
#                     $5 i $6 są opcjonalne (ale $6 implikuje podanie $5)
#
# jeżeli $3 == special to ostatni podany argument zawiera specjalną (pełną) notę Copyright
#                         jeżeli podane zostały jakieś argumenty pomiędzy $3 a ${!#} to są ignorowane
source_join() {
	file_name=$(lang_file_name "$SRC_DIR/$1" body src)
	
	# obsluga zastepowania /**TRSTRING**/ poprzez napisy z pliku tlumaczen
	# /**TRSTRING**/ powinno być umieszczane w ramach stałych napisowych "", ''
	# lub komentarzy innych niż komentzre C (/**/)
	# w przypadku komentarzy C powinno być umieszczane zamiast nich)
	# gdyż samo stanowi komentarz języka C
	: > $TMP_DIR/body.translate.sed
	if [ "`basename $file_name`" = "body.src" -a -f $SRC_DIR/$1/body.translate ]; then
		# format pliku body.translate:
		#  TR_STRING1 LANG /* komentarz C */
		#  TR_STRING2 LANG inny teskt
		while read tr lang str; do
			if [ "$lang" = "$WWW_LANG" ]; then
				echo "s#/**$tr**/#${str//#/\\#}#g" >> "$TMP_DIR/body.translate.sed"
			fi
		done < body.translate
	fi
	
	pierwsza=`sed -n -e '1p' "$file_name" | egrep '(^#!)|(<\?php)'`
	if [ "$pierwsza" = "" ] ; then
		[ "$3" = "yes" ] && std_copyright "$2" "$4" "$5" "$6"
		[ "$3" = "special" ] && special_copyright "$2" "${!#}"
		cat "$(lang_file_name "$SRC_DIR/$1" intro src)"
		sed -f "$TMP_DIR/body.translate.sed" "$file_name"
	else
		echo "$pierwsza"
		[ "$3" = "yes" ] && std_copyright "$2" "$4" "$5" "$6"
		[ "$3" = "special" ] && special_copyright "$2" "${!#}"
		cat "$(lang_file_name "$SRC_DIR/$1" intro src)"
		sed -e '1d' -f "$TMP_DIR/body.translate.sed" "$file_name"
	fi
}

# przetworzrenie źródeł skryptu/programu określonego przez $1 na xml
#  (zawierający xhtml, latex lub inne kodowanie kodu)
# $1 - katalog z plikiem do przetwarzania $2 - katalog wynikowy $3 - poziom nagłówka $4 - id
# $5 - extra rozszerzenie $6 - typ pliku $7 - czy generować plik do pobrania
source2xml() {
	cd "$SRC_DIR"
	dir_name="$1"
	ext="$6"
	if [ -f "$dir_name/body.info" ]; then
		source "$dir_name/body.info"
	fi
	
	case $OUT_MODE in
	"xhtml"*)
		# przygotowanie informacji o pliku do pobrania
		src_link_name=`basename "$dir_name"`
		if [ "$5" != "-" ] ; then
			ext_ext="$5"
		else
			ext_ext=""
		fi
		
		# przygotowanie pliku do pobrania
		if [ "$7" = "no" ]; then
			info=""
		else
			info="<p class=\"fotter\">XHTML generated by highlight (http://www.andre-simon.de/)
			from <a href=\"./$src_link_name$ext_ext\">$src_link_name$ext_ext</a></p>"
			
			source_join "$dir_name" "$ext" "${copyright_mode:-"yes"}" "$years" "$coauthors" "$copyright_add" \
				> "$PAGE_DIR/$2/$src_link_name$ext_ext"
		fi
		
		# wstawienie nagłówka
		if [ "$7" != "no" ]; then
			echo "<head$3 id=\"$4\">`basename "$dir_name"`</head$3>" >> "$PAGE_DIR/$2/body.xml"
		else
			echo "<div id=\"$4\" />" >> "$PAGE_DIR/$2/body.xml"
		fi
		
		# wstawienie kodów xhtml w ramach <pre />
		echo "<pre>" >> "$PAGE_DIR/$2/body.xml"
		if [ "$ext" = "conf" ]; then ext="txt"; fi
		source_join "$dir_name" "$ext" "no" | sed -e 's#\t#  #g' | highlight -f --force -S $ext --out-format=xhtml >> "$PAGE_DIR/$2/body.xml"
		echo "</pre>$info" >> "$PAGE_DIR/$2/body.xml"
		;;
	"latex"*)
		# wstawienie nagłówka
		if [ "$7" != "no" ]; then
			echo "" >> "$PAGE_DIR/body.xml"
			echo "<head$3 id=\"$4\">`basename "$dir_name"`</head$3>" >> "$PAGE_DIR/body.xml"
		else
			echo "<div id=\"$4\" />" >> "$PAGE_DIR/body.xml"
		fi
		
		# wstawienie kodów latex w ramach <latex />
		echo "<latex>" >> "$PAGE_DIR/body.xml"
		[ "$ext" = "conf" ] && ext="txt"
		source_join "$dir_name" "$ext" "no" | highlight -f --force -S $ext --out-format=latex --line-length=93 --wrap-simple -K small |
			sed -e 's#&#\&amp;#g' -e 's#<#\&lt;#g' >> "$PAGE_DIR/body.xml"
		echo -n '</latex>' >> "$PAGE_DIR/body.xml"
		;;
	esac
}

############################################
#     PRZETWARZANIE ZBIORU *.src DO TAR    #
############################################

# $1 - nazwa katalogu pakowanego
# $2 sciezka do umieszczenia postaci rozpakowanej (- gdy nie zamieszczać)
# $3 - sciezka do pliku wynikowego (- gdy nie budowac)
# $4 ... $N lista plikow do dodania do katalogu
make_tar() {
	cd "$SRC_DIR"
	name="$1"
	tar_name=`echo $1 | cut -f1 -d'/'`
	out_tar="$3"
	out_dir="$2"
	
	mkdir -p "$PAGE_DIR/$name"
	
	shift 3
	for f in $@ ; do
		base_name=`basename "$f"`
		if [ -f "$SRC_DIR/$f/body"*.src ] ; then
			ext=`echo $base_name | awk 'BEGIN {FS="."} {print $NF}'`
			if [ -f "$SRC_DIR/$f/body.info" ]; then
				source "$SRC_DIR/$f/body.info"
# 				echo "coauthors=$coauthors" >> "$PAGE_DIR/$tar_name/body.info"
# 				echo "copyright_add=$copyright_add" >> "$PAGE_DIR/$tar_name/body.info"
			fi
			
			source_join "$f" "$ext" "yes"  "$years" "$coauthors" "$copyright_add" \
				> "$PAGE_DIR/$name/$base_name"
			file_name=`lang_file_name "$SRC_DIR/$f" body src`
			touch -m -r "$file_name" "$PAGE_DIR/$name/$base_name"
		elif [ -e "$SRC_DIR/$f" -a ! -e "$PAGE_DIR/$name/$base_name" ] ; then
			ln -sf "$SRC_DIR/$f" "$PAGE_DIR/$name/$base_name"
		fi
	done
	
	if [ "$out_tar" != "-" ] ; then
		cd "$PAGE_DIR"
# 		if [ -f "$PAGE_DIR/$name/body.info" ]; then
# 			coauthors="`grep "coauthors" "$PAGE_DIR/$name/body.info" | cut -s -f2 -d"=" | sort | uniq`"
# 			rm "$PAGE_DIR/$name/body.info"
# 		else
# 			coauthors=""
# 			copyright_add=""
# 		fi
# 		echo -e "$TAR_COPYRIGHT_INTRO" > "$name/LICENCE.txt"
# 		std_copyright "txt" "$STD_YEAR" "$coauthors" >> "$name/LICENCE.txt"
# 		touch -m -t "$TAR_TIME" "$PAGE_DIR/$name/LICENCE.txt"
		
		find "$name" -type d -exec touch -m -t "$TAR_TIME" \{\} \;
		tar -ch --exclude="*.svn*" --exclude="*README.notar.xhtml" -f "tmp.tar" "$name"
		gzip -n "tmp.tar"
		mv "tmp.tar.gz" "$PAGE_DIR/$out_tar"
		
		if [ "$out_dir" != "-" ] ; then
# 			notar_copyright_intro "$out_tar" > "$name/README.notar.xhtml"
# 			std_copyright "htm" "$STD_YEAR" >> "$name/README.notar.xhtml"
			
			mv -f "$name" "$PAGE_DIR/$out_dir"
			echo "notar_url_prefix=`revpath $out_dir`" >> "$PAGE_DIR/$out_dir/body.info"
			echo "use_menu=\"NEVER\"" >> "$PAGE_DIR/$out_dir/body.info"
		else 
			rm -fr "$name"
		fi
		unset coauthors
		unset copyright_add
	fi
	
	unset name tar_name out_tar out_dir
}

#####################################
#     PRZETWARZANIE *.xml DO XML    #
#####################################

# sprawdza czy jest tak <TODO /> i jeżeli tak dodaje artykuł do spisu
check_todo() {
	if grep -q '<TODO' "$1"; then
		todo_title=`xmlstarlet select -t -v '//*/TODO/@title' $1`
		echo "<li><a class=\"int\" href=\"[[!URL""PREFIX!]]$2/[[!URL""POSTFIX!]]#todo\">$todo_title</a></li>" >> "$TMP_DIR/todo_links.xml"
	fi
}

# funkcja łączy pliki xml w większą całość $1 - źródło $2 - cel $3 - poziom nagłówka $4 - id
incxml2xml() {
	input="$(lang_file_name "$SRC_DIR/$1" body xml)"
	
	case $OUT_MODE in
		"xhtml"*)
			check_todo "$input" "$2"
			sed \
				-e '# zamiana znacznika <title> na odpowiedni znacznik <h*>
					s%<title>\(.*\)</title>%<head'$3' id="'$4'">\1</head'$3'>%g' \
				-e '# zamiana znacznika <subtitle /> na odpowiedni znacznik <h*>
					s%<subtitle id="\([^"]*\)">\(.*\)</subtitle>%<div id="'$4':\1" /><head'$(( $3 + 1 ))'>\2</head'$(( $3 + 1 ))'>%g' \
				-e 's%<subtitle>\(.*\)</subtitle>%<head'$(( $3 + 1 ))'>\1</head'$(( $3 + 1 ))'>%g' \
				"$input" >> "$PAGE_DIR/$2/body.xml"
			;;
		"latex"*)
			sed \
				-e '# zamiana znacznika <title> na odpowiedni znacznik <h*>
					s%<title>\(.*\)</title>%<head'$3' id="'$4'">\1</head'$3'>%g' \
				-e '# zamiana znacznika <subtitle /> na odpowiedni znacznik <h*>
					s%<subtitle id="\([^"]*\)">\(.*\)</subtitle>%<head'$(( $3 + 1 ))' id="'$4':\1">\2</head'$(( $3 + 1 ))'>%g' \
				-e 's%<subtitle>\(.*\)</subtitle>%<head'$(( $3 + 1 ))'>\1</head'$(( $3 + 1 ))'>%g' \
				-e '# uzupełnienie linków do zawartości bierzącego katalogu jego pełnym położeniem on-line
					s%<img_from_src %<img_from_src dir="'$2'/" %g' \
				-e '# uzupełnienie linków do zawartości bierzącego katalogu jego pełnym położeniem on-line
					s%<sch_link %<sch_link dir="'$2'/" %g' \
				-e '# uzupełnienie linków do zawartości bierzącego katalogu jego pełnym położeniem on-line
					s%<pcb_link %<pcb_link dir="'$2'/" %g' \
				-e 's%href="\./\([^#]\)%href="'$2'/\1%g' \
				"$input" | grep -v '^[[:space:]]*$' >> "$PAGE_DIR/body.xml"
			;;
	esac
}

##########################################
#     PRZETWARZANIE softdb.xml DO XML    #
##########################################

# funkcja generuje liste oprogramowania w zadanej kategorii do wyjsciowego formatu xml
# $1 - kategoria $2 - cel $3 - poziom nagłówka $4 - id
softdb2xml() {
	cd "$SRC_DIR"
	
	case $OUT_MODE in
		"xhtml"*)
			out_dir="$2"
			;;
		"latex"*)
			out_dir=""
			;;
	esac
	
	xalan -in $SOFTWARE_DB -xsl $ENGINE_DIR/softdb.xsl/body.pl.src -param cat_name "'$1'" -indent 2 | sed \
		-e '# usuniecie naglowka XML
			s#<?xml version="1.0" encoding="[UTFutf]*-8"?>##g' \
		-e '# zamiana znacznika <title> na odpowiedni znacznik <h*>
			s%<title>\(.*\)</title>%<head'$3' id=\"'$4'\">\1</head'$3'>%g' >> "$PAGE_DIR/$out_dir/body.xml"
}

#########################################################
#     PRZETWARZANIE KATALOGU DO GALERII MINIATUR XML    #
#########################################################

# funkcja generuje galerie obrazków w oparciu o tagi umieszczone w plikach img_name.txt
# pliki te definiuja zmienne bash'owe tags (rozdzielana spacjami lista tagów) i desc (opis zdjęcia)
# $1 - wejściowy katalog z fotkami $2 - wynikowy katalog z galeria i fotkami
make_gallery() {
	cp -r -s "$SRC_DIR/$1"/* "$PAGE_DIR/$2/"
	cd "$PAGE_DIR/$2"
	symlinks -rc . &>/dev/null
	
	# zabraniamy używania menu dla podkatalogów
	echo "use_menu=\"NEVER_DOWN\"" >> ./body.info
	
	find -name .svn -type d -exec rm -fr \{\} \; 2> /dev/null
	
	out_file_list="body.xml"
	
	# uzyskanie listy wszystkich plików wraz z tagami
	grep --include=*.txt -R '^tags[ \t]*=' * |
		sed -e 's%^\([^:]*\):[^=]*=\(.*\)$%\1:\2%g' -e 's%[\t ][\t ]*% %g' |
		tr -d "\"'" >  $TMP_DIR/lista_plikow.txt
	
	# uzyskanie listy tagów
	cut -f2 -d':'  $TMP_DIR/lista_plikow.txt | tr ' ' '\n' | sort | uniq >  $TMP_DIR/lista_tagow.txt
	
	echo "<head0>Galerie wg tagów</head0><ul>" > body.xml
	
	# generacja galerii dla każdego z tagów
	while read tag; do
		# nagłówek ...
		col=0
		row=0
		file_num=0
		
		# lista plików z aktualnie przetwazranym tagiem ...
		# możnaby to dac strumieniem do while read ale wtedy problem z zakresem zmiennych w pętli
		grep $tag  $TMP_DIR/lista_plikow.txt | cut -f1 -d':' | sort | uniq >  $TMP_DIR/liasta_plikow_z_tagiem.txt
		# dla każdego pliku z tagiem $tag ..
		while read plik; do
			if [ $row -eq 0 -a $col -eq 0 ]; then
				# nagłówek ...
				out_file="body.$tag.$file_num.xml"
				echo "<head0>Galeria zdjęć dla tagu \"$tag\"</head0>" > $out_file
				echo "<table style=\"text-align: center;\">" >> $out_file
			fi
			# gdy rozpoczeliśmy nowy wiersz
			[ $col -eq 0 ] && echo "<tr>" >> $out_file
			
			# skalowanie obrazka
			fimg="${plik%.txt}"
			
			if [ -e "$fimg" -a ! -e "$fimg.small" ]; then
				suma_kontrolna=`md5sum $fimg | cut -f1 -d ' '`
				if [ -e "$CACHE_DIR/$suma_kontrolna.small_img" ] ; then
					ln -sr "$CACHE_DIR/$suma_kontrolna.small_img" "$fimg.small"
				else
					convert -resize 200x200 "$fimg" "$fimg.small"
					cp "$fimg.small" "$CACHE_DIR/$suma_kontrolna.small_img"
				fi
			fi
			
			# obrazek i informacje o nim
			source "$plik"
			echo " <td>" >> $out_file
			echo "  <a href=\"$fimg\"><img src=\"$fimg.small\" alt=\"$desc\" /></a>" >> $out_file
			echo "  <br />Description: $desc" >> $out_file
			echo "  <br />Tags:" >> $out_file
			for ltag in $tags; do
				echo "  <a href=\"./$ltag.0.[[!URLPOSTFIX!]]\">$ltag</a>" >> $out_file
			done
			fparam=`TZ=UTC ls -lLh --time-style=+"%F %T UTC" "$fimg"`
			fdate=`echo $fparam | awk '{printf("%s %s %s", $6, $7, $8)}'`
			fsize=`echo $fparam | awk '{printf("%s", $5)}'`
			echo "  <br />$fsize, $fdate" >> $out_file
			echo " </td>" >> $out_file
			
			# zwiększenie numeru kolumny w wierszu i sprawdzenie czy nie zakończyliśmy wiersza
			col=$(( $col + 1))
			if [ $col -eq 4 ]; then
				col=0
				echo "</tr>" >> $out_file
				row=$(( $row + 1))
				if [ $row -eq 10 ]; then
					row=0
					file_num=$(( $file_num + 1))
				fi
			fi
		done < $TMP_DIR/liasta_plikow_z_tagiem.txt
		
		# zakończenie ostatniej tabelki
		if [ $col != 0 ]; then
			for col in `seq $col 3`; do
				echo '<td>&nbsp;</td>' >> $out_file
			done
			echo '</tr>' >> $out_file
		fi
		
		# stopki ...
		for out_file in body.$tag.*.xml; do
			echo "</table>" >> $out_file
			
			file_num=`echo ${out_file} | cut -f3 -d.`
			prev_file="$tag."$(( $file_num-1 ))
			next_file="$tag."$(( $file_num+1 ))
			echo "<p>" >> $out_file
			[ -f body.$prev_file.xml ] && echo "<a href=\"./$prev_file.[[!URLPOSTFIX!]]\">POPRZEDNIA STRONA</a> " >> $out_file
			[ -f body.$next_file.xml ] && echo "<a href=\"./$next_file.[[!URLPOSTFIX!]]\">NASTEPNA STRONA</a>" >> $out_file
			echo "</p>" >> $out_file
			
			out_file_list="$out_file_list $out_file"
		done;
		
		# obsługa listy tagów z linkami do galerii w body.xml
		echo "<li><a href=\"./$tag.0.[[!URLPOSTFIX!]]\">$tag</a></li>" >> body.xml
	done <  $TMP_DIR/lista_tagow.txt
	
	echo "</ul>" >> body.xml
	
	# zapisanie listy plików dla kolejnych etapów generowania strony
	echo "multi_body=\"$out_file_list\"" >> body.info
}
