<article>
<title>Zmienne</title>
<p>Jak w każdym przyzwoitym języku programowania możemy korzystać ze zmiennych.</p>

<p>Na wstępie warto wspomnieć o paru parametrach (jest ich trochę więcej) do których dostęp mamy prze $:</p>
<ul>
	<li>0 - nazwa skryptu lub powłoki</li>
	<li>liczba - odpowiedni argument wywołania (parametr pozycyjny)</li>
	<li>* - kolejne parametry pozycyjne, równoważne "$1 $2 ..."</li>
	<li>@ - kolejne parametry pozycyjne, równoważne "$1" "$2" ...</li>
	<li># - liczba parametrów pozycyjnych</li>
	<li>? - kod zakończenia ostatniej instrukcji</li>
</ul>

<p>Prawie wszystkie zmienne w bashu mają zasięg globalny. Wyjątkiem są zmienne odpowiedzialne za przechowywanie argumentów skryptu / funkcji (każda funkcja ma swój niezależny zestaw i nie ma dostępu do argumentów skryptu) oraz zmienne definiowane przy pomocy słowa kluczowego local przed nazwą zmiennej. Kolejnym wyjątkiem są zmienne przekazywane do podprocesów - są one w nich dostępne, ale ich zmiany nie są widoczne w głównym skrypcie - np. (odkomentowanie linii z ps pokazuje dlaczego tak się dzieje):</p>
<pre>zm=1
#ps x -l | tail
echo -e "ttt\nooo" | while read f; do
	zm=$(( $zm + 1 ))
	echo " $zm"
	#ps x -l | tail
done
echo $zm</pre>

<p>Dostępne są też zmienne środowiskowe - takie jak $HOME czy też $PATH, a także np. pseudozmienna $RANDOM zwracająca losową liczbę. Przydatna jest także komenda <code>eval</code> wykonująca komendę powstałą z zczytania przekazanych do niej argumentów (w tym zmiennych) - dzięki jej użyciu możemy np. część konstrukcji case, if czy jakiejś pętli przechowywać w zmiennej (np. <code>LISTA_WYBORU="a) echo AA;; b) echo BB;;"; eval case b in $LISTA_WYBORU esac</code>).</p>

<p>Możliwe jest także (na co najmniej 3 sposoby) wydobycie zawartości zmiennej, której nazwę mamy w innej zmiennej:</p>
<pre>A="to chcemy wyświetlić"; B=A;

# metoda pierwsza
C=${!B}; echo $C

# metoda druga
C='eval "echo \$$B"'; D=`eval "$C"`; echo $D

# metoda trzecia
C=$(C='eval "echo \$$B"'; eval $C); echo $C</pre>
</article>
