<article>
<title>Interfejsy elektroniki</title>

<p>Praktycznie każdy z systemów elektronicznych korzysta z jakiś interfejsów komunikacyjnych. Podstawowym interfejsem jest magistrala (szyna danych i adresów), jej szczegółowe parametry zależą od konkretnego systemu. Szyna systemowa może składać się z osobnej szyny danych (linie oznaczane zazwyczaj D0-Dxx, gdzie xx to bitowość szyny danych) i adresowej (linie oznaczane zazwyczaj A0-Ayy), bądź wspólnych linii (AD) multipleksowanych osobnym sygnałem (AEN) informującym czy aktualnie nadawany jest adres czy dane. Szyna taka zawiera także linie informujące o przeprowadzanej operacji (WR i RD) ich funkcja może być także połączona w jednej linii. Któreś z sygnałów (AEN, WR, RD, lub jakieś inne) pełnią rolę tzw. strobu (zmiana ich stanu decyduje o rozpoczęciu ważności danych / adresów na liniach). W wielu mikroprocesorach szyna dostępna jest w dwóch trybach - pamięci i urządzeń I/O (o trybie pracy decyduje osobna linia). Niekiedy można się spotkać z memory maped I/O czyli udostępnianiem urządzeń w przestrzeni adresowej pamięci (nawet pomimo że architektura wspiera rozdzielenie przestrzeni I/O i pamięci). Warto wspomnieć także o technice <wiki pl="Direct Memory Access">DMA</wiki> umożliwiającej zlecenie wykonania operacji na szynie (np. kopiowania z pamięci do urządzenia) zewnętrznemu kontrolerowi (tak aby nie blokowały one procesora). Zauważalne jest obecnie odchodzenie od koncepcji magistrali (szyny systemowej) na rzecz łączy szeregowych punkt-punkt lub rozwiązań sieciowych opartych na przekazywaniu pakietów.</p>

<p>Dostęp do pamięci czy urządzeń podłączonych do szyny odbywa się za pomocą ich adresów - logika urządzenia musi kontrolować czy w danym cyklu szyny był wywołany jej adres (odpowiednia kombinacja bitów na szynie adresowej) czy nie. W przypadku podłączania standardowych układów często logikę tą konstruujemy samodzielnie i wykorzystujemy wejście chip select /chip enable (CS/CE) do aktywacji lub dezaktywacji układu. Urządzenia nadawcze powinny być wyposażone w bufory trój-stanowe, które dopóki dane urządzenie nie zostanie wywołane do odczytu odłączają je od szyny danych. Urządzenia odbiorcze powinny posiadać rejestry zapamiętujące stan linii danych (interesujących nas bitów z tej linii) w chwili strobu zapisu. Istotne jest także uwzględnianie czasu potrzebnego na skonsumowanie / bądź wystawienie na szynę odpowiednich danych (czas ten musi upłynąć zanim do układu peryferyjnego/pamięci będziemy mogli zapisać kolejną wartość lub zanim dane wystawiane przez układ na liniach danych będą ważne). Niektóre z urządzeń potrafią sygnalizować zakończenie bardziej czasochłonnych operacji (np. pamięci <wiki pl="EEPROM">EEPROM</wiki> dopóki nie zakończą zapisu przy odczycie wystawiają zaprzeczenie zapisywanych danych na D7 lub zmieniają przy każdym kolejnym odczycie wartość D6).</p>

<p>Również często są wykorzystywane standaryzowane interfejsy (głównie szeregowe) takie jak:</p>
<ul>
	<li><wiki pl="Universal Asynchronous Receiver and Transmitter">UART</wiki> (<wiki pl="RS-232">RS232</wiki>, <wiki pl="EIA-485">RS485</wiki>, <wiki pl="RS422">RS422</wiki>, a także światłowodowo np. z wykorzystaniem modułów <wiki pl="TOSLINK">Toslink</wiki>) - uniwersalny asynchroniczny odbiornik i nadajnik, bardzo popularny format komunikacji szeregowej używającej dwóch linii komunikacyjnych (nadawanie i odbiór) oraz niekiedy dodatkowych linii sterujących transmisją, posiada kilka wariantów rozwiązań elektrycznych transmisji (ale konwersja pomiędzy nimi ma charakter czysto elektryczny, w mikrokontrolerach najpopularniejszy jest TTL 5V, rzadziej 3.3V), zarówno odbiornik jak i odbiornik muszą mieć ustawione takie same parametry transmisji (szybkość, znaczenie 9 bitu*, itp), interfejs występujący praktycznie we wszystkich mikrokontrolerach, komputerach jednoukładowych itp.<br />
	*) Standardowym jego wykorzystaniem jest kontrola parzystości, ale jednym z ciekawszych zastosowań 9 bitu jest ustawianie go w bajcie adresowym, i konfigurowanie tylko nadajnika który odebrał swój adres do odbioru danych bez ustawionego 9 bitu (pozostałe nie będą wtedy odbierać danych przeznaczonych dla tamtego nadajnika, ale odbiorą kolejny adres nadawany z ustawionym bitem dziewiątym ...).</li>
	
	<li>interfejsy typowo służących połączeniu mikrokontrolera z czujnikami, modułami I/O, itd:<ul>
		<li><wiki pl="Serial Peripheral Interface">Serial Peripheral Interface</wiki> - interfejs często spotykany w mikrokontrolerach służący do komunikacji z innymi układami, oparty na zasadzie master-slave, wykorzystujący 3 linie (nadawanie, odbiór, zegar) magistralowe oraz zależną od zastosowania liczbę linii wyboru układu (Chip Select), standard wykorzystywany także w programowaniu <wiki pl="In-System Programming">ISP</wiki> dla <wiki pl="AVR">AVR</wiki></li>
		<li><wiki pl="I²C">I2C</wiki> - magistrala dwuliniowa (linia danych i linia zegarowa), obsługująca 7 bitową adresację, umożliwiająca budowę bardziej rozległych systemów niż SPI, często występująca w mikrokontrolerach</li>
		<li><wiki pl="1-Wire">1-Wire</wiki> - jedno przewodowa magistrala (umożliwiająca także zasilanie układów z przewodu magistralowego), obsługująca 64-bitową adresację (adresy ustalane przez producenta układów peryferyjnych, powinny być unikalne w skali globalnej), często stosowana do komunikacji z czujnikami i pamięciami (w tym i-button), niestety praktycznie nigdy nie występująca "na pokładzie" mikrokontrolerów, zatem wymagająca implementacji softwarowej (z ostrymi rygorami czasowymi) lub stosowania układu mostka pomiędzy np. I2C a 1-wire</li>
		<li><wiki pl="Controller Area Network">CAN</wiki> - popularna dwu przewodowa magistrala "przemysłowa" działająca na zasadzie rozgłoszeniowej, obsługująca 11-to lub 29-bitowe identyfikatory, doczekała się niemałej liczby protokołów na niej bazujących takich jak: <wiki en="CANopen">CANopen</wiki>, <wiki en="CAN Kingdom">CAN Kingdom</wiki>, <wiki en="MilCAN">MilCAN</wiki>, <wiki en="SafetyBUS p">SafetyBUS p</wiki></li>
	</ul></li>
	
	<li>interfejsy typowo służących połączeniu komputera z urządzeniami peryferyjnymi:<ul>
		<li><wiki pl="Universal Serial Bus">USB</wiki> - popularny zwłaszcza w komputerach (a co za tym idzie urządzeniach które chcemy do nich podłączać) magistrala szeregowa, możliwa ale dość trudna w implementacji softwarowej częściej uzyskiwana za pomocą konwersji z UART, niekiedy wbudowana obsługa w mikrokontroler.</li>
		<li><wiki pl="FireWire">IEEE1394</wiki> - stosunkowo mało popularny interfejs, zwany też FireWire, występujący głównie w sprzęcie wideo oraz w niektórych przyrządach pomiarowych.</li>
		<li><wiki pl="IEEE 1284">LPT</wiki></li>
	</ul></li>
	<li>interfejsy typowo służących połączeniu komputera z wewnętrznymi modułami: <wiki pl="ISA">ISA</wiki>, <wiki pl="Peripheral Component Interconnect">PCI</wiki>, <wiki pl="PCI Express">PCI Express</wiki>, <wiki pl="ATA (technologia)">ATA</wiki>, <wiki pl="Serial ATA">SATA</wiki>, <wiki pl="SCSI">SCSI</wiki>, <wiki pl="Serial Attached SCSI">SAS</wiki>, ...</li>

	<li><wiki pl="Ethernet">Ethernet</wiki> - standard sieci komputerowych zyskujący coraz większe znaczenie w komunikacji urządzeń elektronicznych takich jak sterowniki, kontrolery itp, wygodny w użyciu, umożliwia stosowanie <wiki pl="Model TCP/IP">TCP/IP</wiki>. Niektóre z mikrokontrolerów posiadają warstwę MAC w sobie (co pozwala na dołączenie tylko prostszego układy warstwy fizycznej PHY), w przeciwnym razie konieczne jest dołączenie całego układu kontrolera sieciowego.</li>
</ul>

<p>Istotnymi interfejsami komunikacyjnymi systemów elektronicznych są współcześnie sieci. Rozwiązania sieciowe mogą wykorzystywać jako warstwę sprzętową któryś z opisanych powyżej interfejsów szeregowych (w zasadzie poza UART i po części SPI wszystkie one są sieciami opisującymi 1 i 2 warstwę wg. modelu OSI) albo posiadać własny standard interfejsu (np. światłowodowy, bezprzewodowy, wykorzystujący okablowanie energetyczne). Obecnie popularność Ethernetu staje się na tyle istotna iż zaczyna on wypierać popularne dotychczas standardy sieci przemysłowych służących do komunikacji pomiędzy sterownikami (<wiki en="Fieldbus">fieldbus</wiki>) takie jak: <wiki en="INTERBUS">Interbus</wiki>, <wiki pl="Foundation Fieldbus">Foundation Fieldbus</wiki>, <wiki pl="CC-Link">CC-Link</wiki>. Ponadto zauważalna jest migracja wielu protokołów tego typu sieci (standardów nie definiujących warstwy fizycznej i łącza danych) w stronę wykorzystania Ethernetu czy nawet TCP/IP, za przykłady mogą posłużyć tutaj:</p>
<ul>
	<li><wiki pl="Modbus">Modbus</wiki> - protokół wykorzystujący jako łącza transmisyjne UART lub Ethernet (zobacz: <id_link id="libs4avr:modbus">Modbus dla AVR</id_link> z uzyciem <homepage url="http://www.freemodbus.org/">FreeMODBUS</homepage>, <id_link id="monitoring:modbus_rtu">Master modbus RTU</id_link>, <homepage url="http://libmodbus.org/">libmodbus</homepage></li>
	<li><wiki pl="BACnet">BACnet</wiki> - otwarty protokół komunikacyjny mogący korzystać m.in. z warstwy IP</li>
	<li><wiki pl="M-Bus">M-BUS</wiki> - dwu częściowa (format komunikatów i sposób transmisji przez sieć energetyczną) sieć do komunikacji z licznikami energii itp</li>
	<li><wiki en="Profibus">Profibus DP</wiki> - popularny standard sieci, wykorzystujący w warstwie fizycznej łącza RS485, optyczne lub transmisję po liniach energetycznych korzystający zarówno z mechanizmu odpytywania master-slave jak i wymiany znaczników pomiędzy masterami (<wiki pl="Token passing">token passing</wiki>, tak jak w wymierającym już standardzie sieci komputerowych <wiki pl="Token ring">Token Ring</wiki>), aktualnym kierunkiem ewolucyjnym tego standardu jest oparta na Ethernecie sieć <wiki en="PROFINET">Profinet</wiki></li>
	<li><wiki pl="S-Bus">S-bus</wiki> - protokół wykorzystujący jako łącza transmisyjne UART lub Ethernet</li>
	<li><wiki en="LonWorks">LonWorks</wiki> - protokół komunikacyjny dla automatyki głównie <wiki pl="Inteligentny budynek">inteligentnych budynków</wiki>, który dzięki użyciu <wiki pl="IP-852">IP-852</wiki> może być przesyłany z użyciem sieci TCP/IP.</li>
</ul>
<p>W tym miejscu należy też wspomnieć o protokołach używanych do udostępniania informacji przez różne systemy w sieciach TCP/IP takich jak:</p>
<ul>
	<li><wiki pl="Simple Network Management Protocol">SNMP</wiki></li>
	<li><wiki pl="OLE for process control">OPC</wiki> (pomimo Windowsowych korzeni posiada także otwarte implementacje w pythonie działające także w innych systemach - <homepage url="http://openopc.sourceforge.net/" mirror="soft/OpenOPC">OpenOPC for Python</homepage>, <homepage url="http://pyopc.sourceforge.net/" mirror="soft/OpenOPC">PyOPC</homepage>)</li>
</ul>
<p>W specyficznych zastosowaniach (np. motoryzacja) można spotkać wiele innych rozwiązań w mniejszym bądź większym stopniu zbliżonych do tu wymienionych.</p>

</article>
